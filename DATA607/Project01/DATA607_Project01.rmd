---
title: "DATA607 Project 1 - Chess Tournament"
author: "Jai Jeffryes"
date: "9/22/2019"
output:
  html_document:
    df_print: paged
    keep_md: true
---

```{r setup, include=TRUE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "./../..")

library(data.table) # fread()
library(dplyr) # mutate()
library(stringr)

assign_dir <- "./DATA607/Project01"
assign_data <- paste(assign_dir, "data", sep = "/")
```

## Introduction
Project 1 reads chess tournament data, transforms it, and outputs a format that could be loaded into a relational database. The chess tournament data is in a consistent, though unstructured, format, hence the necessity to transform it.

## Requirements
- *Project 1.pdf*. Located in the project's working directory.
- [Reading a Chess Tournament Cross Table](https://www.youtube.com/watch?v=T5PXYl2FEUo). YouTube video with orientation and requirement constraints.

Most of the requirements pertain to reporting data of interest from the chess tournament input file. There is one reporting requirement that adds value to the input data, summarization of opponents' pre-tournament ratings.

Note these exclusions from scope per the YouTube video.

1. Summarization of rounds with results other than a win or a loss.
1. Summarization of pre-tournament ratings with non-numeric characters (e.g. "P").

### Assumptions
For computation of oppenents' average pre-tournament ratings, excluded values reduce the counts. There is no imputation of missing values for out-of-scope rounds or pre-tournament ratings.

## Input
- Source data: [tournamentinfo.txt](https://bbhosted.cuny.edu/bbcswebdav/pid-42267955-dt-content-rid-347468182_1/courses/SPS01_DATA_607_01_1199_1/tournamentinfo.txt)
- Download date: Mon Sep 16 19:21:59 2019
- Location for processing: `r assign_data`.

## Output
Data processing produces a list of data frames. The name of the list is created at run time. Depositing the output into a list permits processing of multiple input files and retaining their output separately.

The output list contains these data frames:

- `chess_raw`. Raw data from the input file. No cleansing.
- `chess_split`. Cleansing has started. Header rows and separator rows are removed. Fields of the data rows are split by the delimiter.
- `chess_xform`. The input file format allots two rows for each player. This data frame reorganizes them  side by side into a single row for each player. Names are applied to columns. The source columns from `chess_split` are retained. Transformations are applied to transformation columns in the same row.
- `player_df`. Reporting table for players. The average pre-rating for a player's opponents appears in this table.
- `round_df`. Reporting table for chess round results, organized in a Tidy format.

## Functions
- `split_cols()`. Athough the input file delimits data, it also contains non-data visual separating rows. Therefore, file reading functions within base R are unable to split the columns. This function assumes deletion of the separator rows and splits on a column separator. It preserves the raw data and appends to it the split columns.
- `merge_player_rows()`. Player data is recorded in two rows. The formats of the two rows are different from each other, while remaining consistent from player to player. This function arranges each player's two rows side-by-side, forming a single record per player.
- `xform_data()`. Transforms the raw data. Data types are coerced where necessary. Out-of-scope ratings are left unmapped. The functions supports flexibility in the input of data for rounds. Any number of rounds can be included.
- `read_rounds()`. The input file records tournament round results in a cross tab format. This function pivots the rounds into a Tidy format for aggregation and reporting. The function supports input of files with any number of rounds.
- `process_file()`.
  - Reads data file. Probes it for the number of rounds.
  - Begins data cleansing.
  - Calls function to split columns.
  - Calls function to transform columns.
```{r functions}
split_cols <- function(df, sep) {
	# Reference:
	# https://www.r-bloggers.com/converting-strsplit-output-to-a-data-frame/
	
	# Names for split columns.
	num_cols <- str_count(df[1, ], sep) + 1 # Record ends in trailing separator
	cols <- paste0("split", 1:num_cols)
	
	# Split the records. Unstructured.
	df_tmp <- unlist(str_split(df[ , 1], sep))
	# Pointer for head of each split record
	split_idx <- seq(from = 1, by = num_cols, length = nrow(df))

	# Append split columns.
	# Omit last empty column.
	for (i in 1:(num_cols - 1)) {
		df[, cols[i]] <- df_tmp[split_idx + i -1]
	}
	
	# Return
	df
}

merge_player_rows <- function(df, col_range_1, col_range_2) {
	df1 <- df[ , col_range_1] %>% filter(row_number() %% 2 == 1)
	names(df1) <- paste0("left_", names(df1))
	df2 <- df[ , col_range_2] %>% filter(row_number() %% 2 == 0)
	names(df2) <- paste0("right_", names(df2))
	
	df_merge <- cbind(df1, df2)
	
	# Return
	df_merge
}

xform_data <- function(df) {
	# Player number.
	df$player_num_xfm <- as.integer(df$player_number_src)
	# Player name. Format case.
	df$player_name_xfm <- str_to_title(str_trim(df$player_name_src))
	# State.
	df$state_xfm <- str_trim(df$state_src)
	# Points.
	df$points_xfm <- as.numeric(df$points_src)
	# Rounds
	round_col_count <- sum(str_detect(names(df), "round"))
	for (i in 1:round_col_count) {
		# Round result.
		df[ , str_c("round", i, "_result_xfm")] <- 
			str_extract(df[ , paste0("round", i, "_src")], "^\\w")
		# Opponent number
		df[ , str_c("round", i, "_opponent_xfm")] <- 
			as.integer(str_extract(df[ , paste0("round", i, "_src")], "\\d+"))
	}
	# State
	df$state_xfm <- str_trim(df$state_src)
	# USCF ID
	df$uscf_id_xfm <- as.integer(str_extract(str_trim(df$uscf_id_rating_src), "^\\d+"))
	# Rating
	# Rating must be followed by whitespace. Exclude the "P" ratings.
	df$rating_xfm <- as.integer(str_match(df$uscf_id_rating_src, "(R:\\s)(\\d+)\\s")[,3])
	
	#Return
	df
}

read_rounds <- function(df) {
	round_df <- data.frame(
		round <- integer(),
		result <- character(),
		player_num <- integer(),
		opponent_num <- integer(),
		stringsAsFactors = FALSE)
	
	round_count <- sum(str_detect(names(df), "round\\d_result_xfm"))
	
	for (i in 1:round_count) {
		result_col_idx <- which(names(df) == str_c("round", i, "_result_xfm"))
		opponent_col_idx <- which(names(df) == str_c("round", i, "_opponent_xfm"))
		
		round_row <- df %>%
			select(result = result_col_idx,
				   player_num = player_num_xfm,
				   opponent_num = opponent_col_idx)
		# Add round number separately because
		# dplyr doesn't select literals.
		round_row <- cbind(round = i, round_row)
		
		round_df <- rbind(round_df, round_row)
	}
	
	# Return
	round_df
}

process_file <- function(dat_file) {
	# CONSTANTS
	sep <- "\\|" # Column separator 

	out <- list() # Output multiple data frames
	
	# Read as unstructured text.
	out$chess_raw <- fread(dat_file, sep = NULL, header = FALSE)
	
	# Count rounds
	# Headings are in row 2 of the raw data.
	round_count <- str_count(toupper(out$chess_raw[2, 1]), "ROUND")
	
	# Columns used in each record type.
	player_rec1_col_range <- 2:(4 + round_count)
	player_rec2_col_range <- 2:3
	
	# Remove column descriptions and separators.
	out$chess_split <- out$chess_raw %>% 
		filter(row_number() %% 3 != 1 & row_number() > 4)
	
	# Append split columns.
	out$chess_split <- split_cols(df = out$chess_split, sep = sep)
	
	# Merge row pairs into records
	out$chess_xform <- merge_player_rows(
		out$chess_split,
		player_rec1_col_range,
		player_rec2_col_range)
	
	# Name the transformation columns
	names(out$chess_xform) <- c(
		"player_number_src",
		"player_name_src",
		"points_src",
		paste0("round", 1:round_count, "_src"),
		"state_src",
		"uscf_id_rating_src"
	)
	
	# Transform
	out$chess_xform <- xform_data(out$chess_xform)

	return(out)
}

load_data <- function(dat_list) {
	# Define PLAYER data frame.
	player_df <- data.frame(
		player_num <- integer(),
		player_name = character(),
		state = character(),
		total_points = integer(),
		pre_rating = integer(),
		stringsAsFactors = FALSE)
	
	# Define ROUND data frame.
	round_df <- data.frame(
		round <- integer(),
		result <- character(),
		player_num <- integer(),
		opponent_num <- integer(),
		stringsAsFactors = FALSE)
	
	# Load PLAYER data frame.
	# print(str(dat_list))
	# dat_list$player_df <- 

	chess_xfm <- dat_list[[3]]
	
	player_df <- chess_xfm %>%
		select (player_num = player_num_xfm,
				player_name = player_name_xfm,
				state = state_xfm,
				total_points = points_xfm,
				pre_rating = rating_xfm)
	dat_list$player_df <- player_df

	# Load ROUND data frame.
	round_df <- read_rounds(chess_xfm)
	dat_list$round_df <- round_df
	
	return(dat_list)
}

append_summaries <- function(dat_list) {
	round_df <- dat_list[[5]]
	player_df <- dat_list[[4]]
	
	# Question: Is there a single-pass way to add the summary column to player_df, perhaps using mutate()?
	opponent_prerating_df <- 
		inner_join(x = round_df, y = player_df, by = c("opponent_num" = "player_num")) %>%
		filter(!is.na(pre_rating)) %>%
		group_by(player_num) %>%
		summarize(opponents_pre_rating = mean(pre_rating)) 
	
	player_df <- inner_join(x = player_df, y = opponent_prerating_df)
	
	dat_list$player_df <- player_df

	return(dat_list)	
}
```
## Process and load
```{r}
dat_file_name <- "tournamentinfo.txt"
# Fully qualified path.
dat_file <- paste(assign_data, dat_file_name, sep = "/")

# Process
tournamentinfo_list <- process_file(dat_file)

# Load 
tournamentinfo_list <- load_data(tournamentinfo_list)

# Append summaries
tournamentinfo_list <- append_summaries(tournamentinfo_list)
```
## Inspect results
```{r}
# Data frames in the list
names(tournamentinfo_list)

# Top of each data frame
lapply(tournamentinfo_list, print(head))
```

## Report
The requirements specify the form to output a CSV file. Note that the specification omits the player number. I discuss this in [Loading MySQL](#loading-mysql) under the Supplements section.
```{r}
# Output the file.
player_file <- paste(assign_data, "player.csv", sep = "/")
write.csv(tournamentinfo_list$player_df[ , -1], player_file, row.names = FALSE)

# Inspect the file
report <- read.csv(player_file)
head(report)
```

Location of output file: `r player_file`

## Supplements
### Loading MySQL
In a previous assignment about MySQL, the grader challenged me to learn how to populate tables without relying on `INSERT` statements. The current project was an opportunity to do that.

Loading text files into MySQL relies on the `LOAD DATA` scripting command. [Link to Documentation](https://dev.mysql.com/doc/refman/8.0/en/load-data.html)

There is a command line interface for invocation of `LOAD DATA`, [mysqlimport](https://dev.mysql.com/doc/refman/8.0/en/mysqlimport.html).

#### HeidiSQL
`LOAD DATA` is detailed and specific in its use. Building the command is aided by the third-party open source tool [HeidiSQL](https://www.heidisql.com/download.php). HeidiSQL is a Windows-based program.

- Since I develop in Ubuntu Linux, it required installation of the Wine package. These [Wine installation instructions](https://vitux.com/how-to-install-wine-on-ubuntu/) introduced me to a new Linux command, `lscpu`, for reviewing system properties of my CPU. HeidiSQL runs well under Wine, with a Gold status on the [Wine HQ AppDB](https://appdb.winehq.org/appview.php?iAppId=3326).
- The website for HeidiSQL says the application runs under Winde, but does not document its installation under Wine. I found some instructions on [AskUbuntu](https://askubuntu.com/questions/459074/how-to-install-heidisql-on-ubuntu). They were incomplete, though. I was unable to run the installer from the desktop. I needed to root on my terminal with `sudo -i` and run the setup program like this: `wine ./HeidiSQL_10.2.0.5599_Setup.exe`. (f course, I snapshot my virtual machine in VirtualBox before fooling around with any of this.)
